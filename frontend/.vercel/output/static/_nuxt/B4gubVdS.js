import{R as k,p as c,S as i,U as g,V as d}from"./DE86NBQu.js";const f="0xdc9EF61C70Dd0fd144AF3cFBb2dc30e7b5A8A717",v="0xBA6D102E57Bda979B68BC4c0c47980CeBeF9075b",m=["function stake(uint256 _amount) external","function withdraw(uint256 _amount) external","function claimRewards() external","function getPendingRewards(address user) view returns (uint256)","function stakers(address user) view returns (uint256 amount, uint256 rewardDebt, uint256 lastStakedTime)"],b=["function balanceOf(address) view returns (uint256)","function decimals() view returns (uint8)","function symbol() view returns (string)","function approve(address spender, uint256 amount) external returns (bool)","function transfer(address to, uint256 amount) external returns (bool)","function decimals() view returns (uint8)","function totalSupply() view returns (uint256)"],p=k("wallet",{state:()=>({address:"",isConnected:!1,provider:null,account:"",isConnected:!1,chainId:null,netWorkName:"",totalBalance:"0",pendingRewards:"0",stakedAmount:"0",signer:null,tokenContracts:{HIVE:{address:v,abi:b}},stakeHiveContracts:{STAKEHIVE:{address:f,abi:m}}}),actions:{async connectWallet(){const{$web3Provider:e,$ethers:t}=c();try{const a=e.provider,n=await a.getNetwork();this.provider=a,this.chainId=n.chainId,this.netWorkName=n.name;const r=await window.ethereum.request({method:"eth_requestAccounts"});if(this.account=r[0],this.isConnected=this.account.length>0,this.signer=e.getSigner(),!this.signer){console.warn("Signer is not set.");return}await this.loadStakingData()}catch(a){console.error("Error connecting to wallet:",a)}},async getWalletBalance(e){try{const t=await e.getBalance(this.account);this.totalBalance=d(t),console.log("totalBalance",this.totalBalance)}catch(t){console.error("Error fetching wallet balance:",t),this.balance="0"}},async getTokenBalance(e){try{const t=this.tokenContracts.HIVE,n=await new i(t.address,t.abi,e).balanceOf(this.account);this.tokenBalance=d(n)}catch(t){console.error("Error fetching token balance:",t)}},async getStakingData(e){try{const t=this.stakeHiveContracts.STAKEHIVE,a=new i(t.address,t.abi,e),n=await a.getPendingRewards(this.account);this.pendingRewards=d(n);const r=await a.stakers(this.account);this.stakedAmount=d(r.amount),this.rewardDebt=d(r.rewardDebt),console.log("web3Provider",e),console.log("provider",this.provider),console.log("signer",this.signer)}catch(t){console.error("Error fetching staking data:",t)}},async stake(e){console.log("amountinEther-------------------",e);const{$web3Provider:t}=c();try{const a=t.getSigner(),n=this.stakeHiveContracts.STAKEHIVE,r=t.provider,o=this.tokenContracts.HIVE,l=new i(o.address,o.abi,a),w=await l.decimals(),s=g(e.toString(),18);console.log("requested amountinEther:",s);const h=await l.approve(n.address,s);await h.wait(),console.log("Token approved for staking:",h);const u=await new i(n.address,n.abi,a).stake(s);return await u.wait(),console.log("Staking transaction sent:",u),await this.loadStakingData(),u}catch(a){console.error("Error staking:",a)}},async claimRewards(){try{const e=this.stakeHiveContracts.STAKEHIVE,{$web3Provider:t}=c(),a=t.getSigner(),n=t.provider,o=await new i(e.address,e.abi,a).claimRewards();return console.log("Claiming tx sent:",o.hash),await o.wait(),console.log("ClaimRewards tx confiremed:",o),await this.loadStakingData(),o}catch(e){console.error("Error claiming rewards:",e)}},async withdraw(e){const{$web3Provider:t}=c();try{if(!e||Number(e)<=0)throw new Error("Invalid withdrawal amount");const a=await t.getSigner(),n=this.stakeHiveContracts.STAKEHIVE,r=new i(n.address,n.abi,a),o=g(e.toString(),18);if((await r.stakers(this.account)).amount<o)throw new Error("Insufficient staked amount for withdrawal");const w=await r.withdraw(o);console.log("Withdraw tx sent:",w.hash);const s=await w.wait();if(s.status!==1)throw new Error("Transaction failed on-chain");return await this.loadStakingData(),{hash:s.transactionHash,receipt:s,error:null}}catch{}},async loadStakingData(){const{$web3Provider:e}=c(),t=e.provider;await this.getWalletBalance(t),await this.getTokenBalance(t),await this.getStakingData(t)}}});export{p as u};
